{"ast":null,"code":"export function createTrackingData(reaction) {\n  var trackingData = {\n    reaction: reaction,\n    mounted: false,\n    changedBeforeMount: false,\n    cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS\n  };\n  return trackingData;\n}\n/**\r\n * The minimum time before we'll clean up a Reaction created in a render\r\n * for a component that hasn't managed to run its effects. This needs to\r\n * be big enough to ensure that a component won't turn up and have its\r\n * effects run without being re-rendered.\r\n */\n\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\r\n * The frequency with which we'll check for leaked reactions.\r\n */\n\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;","map":{"version":3,"mappings":"AAEA,OAAM,SAAUA,kBAAV,CAA6BC,QAA7B,EAA+C;EACjD,IAAMC,YAAY,GAAsB;IACpCD,QAAQ,UAD4B;IAEpCE,OAAO,EAAE,KAF2B;IAGpCC,kBAAkB,EAAE,KAHgB;IAIpCC,OAAO,EAAEC,IAAI,CAACC,GAAL,KAAaC;EAJc,CAAxC;EAMA,OAAON,YAAP;AACH;AAkDD;;;;;;;AAMA,OAAO,IAAMM,qCAAqC,GAAG,KAA9C;AAEP;;;;AAGA,OAAO,IAAMC,yBAAyB,GAAG,KAAlC","names":["createTrackingData","reaction","trackingData","mounted","changedBeforeMount","cleanAt","Date","now","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","CLEANUP_TIMER_LOOP_MILLIS"],"sources":["D:\\Github\\mobx\\multiple-mobx\\node_modules\\mobx-react-lite\\src\\utils\\reactionCleanupTrackingCommon.ts"],"sourcesContent":["import { Reaction } from \"mobx\"\r\n\r\nexport function createTrackingData(reaction: Reaction) {\r\n    const trackingData: IReactionTracking = {\r\n        reaction,\r\n        mounted: false,\r\n        changedBeforeMount: false,\r\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS\r\n    }\r\n    return trackingData\r\n}\r\n\r\n/**\r\n * Unified api for timers/Finalization registry cleanups\r\n * This abstraction make useObserver much simpler\r\n */\r\nexport interface ReactionCleanupTracking {\r\n    /**\r\n     *\r\n     * @param reaction The reaction to cleanup\r\n     * @param objectRetainedByReact This will be in actual use only when FinalizationRegister is in use\r\n     */\r\n    addReactionToTrack(\r\n        reactionTrackingRef: React.MutableRefObject<IReactionTracking | null>,\r\n        reaction: Reaction,\r\n        objectRetainedByReact: object\r\n    ): IReactionTracking\r\n    recordReactionAsCommitted(reactionRef: React.MutableRefObject<IReactionTracking | null>): void\r\n    forceCleanupTimerToRunNowForTests(): void\r\n    resetCleanupScheduleForTests(): void\r\n}\r\n\r\nexport interface IReactionTracking {\r\n    /** The Reaction created during first render, which may be leaked */\r\n    reaction: Reaction\r\n    /**\r\n     * The time (in ticks) at which point we should dispose of the reaction\r\n     * if this component hasn't yet been fully mounted.\r\n     */\r\n    cleanAt: number\r\n\r\n    /**\r\n     * Whether the component has yet completed mounting (for us, whether\r\n     * its useEffect has run)\r\n     */\r\n    mounted: boolean\r\n\r\n    /**\r\n     * Whether the observables that the component is tracking changed between\r\n     * the first render and the first useEffect.\r\n     */\r\n    changedBeforeMount: boolean\r\n\r\n    /**\r\n     * In case we are using finalization registry based cleanup,\r\n     * this will hold the cleanup token associated with this reaction\r\n     */\r\n    finalizationRegistryCleanupToken?: number\r\n}\r\n\r\n/**\r\n * The minimum time before we'll clean up a Reaction created in a render\r\n * for a component that hasn't managed to run its effects. This needs to\r\n * be big enough to ensure that a component won't turn up and have its\r\n * effects run without being re-rendered.\r\n */\r\nexport const CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10_000\r\n\r\n/**\r\n * The frequency with which we'll check for leaked reactions.\r\n */\r\nexport const CLEANUP_TIMER_LOOP_MILLIS = 10_000\r\n"]},"metadata":{},"sourceType":"module"}